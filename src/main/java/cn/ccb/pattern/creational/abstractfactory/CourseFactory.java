package cn.ccb.pattern.creational.abstractfactory;

/**
 * 定义：抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类(也就是将一系列具有同一主题的工厂封装起来)
 * 类型：创建型
 *
 *使用场景：
 * 1.客户端(应用层)不依赖于产品类实例如何被创建、实现等细节。
 * 2.强调一系列相关的产品对象(属于同一产品祖)一起使用创建对象需要大量重复代码。
 * 3.提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。
 * 4.产品等级较为固定的，不会频繁有新增产品登记的需求出现的场景
 *
 * 优点：
 * 1.具体产品在应用层代码隔离，无需关心创建细节
 * 2.将一个系列的产品族同一到一起创建
 *
 * 缺点：
 * 1.规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。
 * 2.增加了系统的抽象性和理解难度。
 * 3.增加新的产品等级后，要对原有的系统进行较大的修改，此时不符合开闭原则。
 *
 * 产品等级：同一产品等级结构即产品的继承结构，如有一个抽象类空调，格力的空调，美的的空调，海尔的空调都继承于它，则这三者为同一产品等级结构
 * 产品族：在抽象工厂供，产品族是指由同一个工厂生产的，从属于不同产品等级结构的产品，如，格力，可以生产空调，冰箱，电视等，
 *
 * 工厂方法与抽象工厂的对比：工厂方法比较适用于同一产品等级结构的对象生产，但是当要生产不同产品等级结构的独享时，我们需要重新构建对应产品
 * 的工厂的抽象类及实现类，以及要生产的产品本身，这样会造成类的爆炸式增长，不利于维护。而此时可以使用抽象工厂，抽象工厂更适用于同一产品族的对象生产。
 * 但是抽象工厂要新增产品等级结构时，要对系统做出比较大的修改，所以抽象工厂更使用与产品族内的产品等级结构较为固定的场景。
 *
 * 源码中的体现：
 * 1.{@link java.sql.Connection} 该类创建Statement和PrepareStatement对象时，这两个对象属于同一产品族，Connection对象就相当于一个抽象工厂，
 * 我们可以通过其不同的实现创建输入mysql或oracle等数据库对应的产品对象
 * 2.Mybatis的SQLSessionFactory也是一个抽象工厂
 */
public interface CourseFactory {

    Video getVideo();

    Article getArticle();
}
